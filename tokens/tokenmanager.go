package tokens

import (
	"context"
	"crypto"
	"crypto/ed25519"
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"net/url"
	"sort"
	"strings"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/lestrrat-go/jwx/v3/jwa"
	"github.com/lestrrat-go/jwx/v3/jwk"
	"github.com/oklog/ulid/v2"
	"github.com/rs/zerolog/log"
	"github.com/theopenlane/utils/ulids"
)

const DefaultRefreshAudience = "https://auth.theopenlane.io/v1/refresh"

// the signing method should match the value returned by the JWKS
var (
	signingMethod        = jwt.SigningMethodEdDSA
	nilID                = ulid.ULID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	ErrEmptySigningKeyID = errors.New("signing key identifier is empty")
)

type loadedKey struct {
	kid     string
	ulid    ulid.ULID
	hasULID bool
}

// TokenManager handles the creation and verification of EdDSA signed JWT tokens. To
// facilitate signing key rollover, TokenManager can accept multiple keys identified by
// a ulid. JWT tokens generated by token managers include a kid ("Key ID") in the header that
// allows the token manager to verify the key with the specified signature. To sign keys
// the token manager will always use the latest private key by ulid.
//
// When the TokenManager creates tokens it will use JWT standard claims as well as
// extended claims based on usage. The standard claims included are exp, nbf
// aud, and sub. On token verification, the exp, nbf, iss and aud claims are validated.
type TokenManager struct {
	validator
	refreshAudience string
	conf            Config
	currentKeyID    string
	currentKey      crypto.Signer
	keys            map[string]ed25519.PublicKey
	signingKeys     map[string]crypto.Signer
	kidEntropy      io.Reader
	blacklist       TokenBlacklist
	loader          signerLoader
}

// New creates a TokenManager with the specified keys which should be a mapping of key identifiers
// to filesystem paths containing PEM-encoded Ed25519 private keys. This input is specifically
// designed for the config environment variable so that keys can be loaded from k8s or vault
// secrets that are mounted as files on disk
func New(conf Config) (tm *TokenManager, err error) {
	tm = &TokenManager{
		validator: validator{
			audience: conf.Audience,
			issuer:   conf.Issuer,
		},
		conf:        conf,
		keys:        make(map[string]ed25519.PublicKey),
		signingKeys: make(map[string]crypto.Signer),
		kidEntropy: &ulid.LockedMonotonicReader{
			MonotonicReader: ulid.Monotonic(rand.Reader, 0),
		},
		loader: defaultSignerLoader{},
	}
	tm.validator.keyFunc = tm.keyFunc

	keyIDs := make([]string, 0, len(conf.Keys))
	for kid := range conf.Keys {
		keyIDs = append(keyIDs, kid)
	}

	sort.Strings(keyIDs)

	loaded := make([]loadedKey, 0, len(keyIDs))

	for _, kid := range keyIDs {
		path := conf.Keys[kid]

		signer, loadErr := tm.loader.Load(path)
		if loadErr != nil {
			return nil, newParseError("path - retrieve", path, loadErr)
		}

		if err = tm.addSigningKeyWithID(kid, signer); err != nil {
			return nil, err
		}

		info := loadedKey{kid: kid}
		if parsed, parseErr := ulid.Parse(kid); parseErr == nil {
			info.ulid = parsed
			info.hasULID = true
		}

		loaded = append(loaded, info)
	}

	tm.selectInitialKey(loaded, conf.KID)

	if tm.currentKey == nil {
		return nil, ErrTokenManagerFailedInit
	}

	tm.conf.KID = tm.currentKeyID

	// Initialize with no-op blacklist by default
	tm.blacklist = NewNoOpTokenBlacklist()
	tm.validator.blacklist = tm.blacklist

	return tm, nil
}

// WithBlacklist sets the token blacklist for the TokenManager
func (tm *TokenManager) WithBlacklist(blacklist TokenBlacklist) *TokenManager {
	tm.blacklist = blacklist
	tm.validator.blacklist = blacklist

	return tm
}

// NewWithKey is a constructor function that creates a new instance of the TokenManager struct
// with a specified Ed25519 signing key. It takes in the signing key as a parameter and initializes the
// TokenManager with the provided key, along with other configuration settings from the TokenConfig
// struct. It returns the created TokenManager instance or an error if there was a problem
// initializing the TokenManager.
//
// NOTE: Breaking change in the EdDSA migration requires callers to supply a crypto.Signer.
func NewWithKey(key crypto.Signer, conf Config) (tm *TokenManager, err error) {
	tm = &TokenManager{
		validator: validator{
			audience: conf.Audience,
			issuer:   conf.Issuer,
		},
		conf:        conf,
		keys:        make(map[string]ed25519.PublicKey),
		signingKeys: make(map[string]crypto.Signer),
		kidEntropy: &ulid.LockedMonotonicReader{
			MonotonicReader: ulid.Monotonic(rand.Reader, 0),
		},
	}
	tm.validator.keyFunc = tm.keyFunc

	var kid ulid.ULID

	if kid, err = tm.genKeyID(); err != nil {
		return nil, err
	}

	if err = tm.addSigningKeyWithID(kid.String(), key); err != nil {
		return nil, err
	}

	tm.currentKey = key
	tm.currentKeyID = kid.String()
	tm.conf.KID = tm.currentKeyID

	// Initialize with no-op blacklist by default
	tm.blacklist = NewNoOpTokenBlacklist()
	tm.validator.blacklist = tm.blacklist

	return tm, nil
}

// Sign an access or refresh token and return the token
func (tm *TokenManager) Sign(token *jwt.Token) (string, error) {
	if tm.currentKey == nil || tm.currentKeyID == "" {
		return "", ErrTokenManagerFailedInit
	}

	// Add the kid to the header
	token.Header["kid"] = tm.currentKeyID

	// Return the signed string
	return token.SignedString(tm.currentKey)
}

const (
	// Default durations for different impersonation types - kept short for security
	supportImpersonationDuration = 30 * time.Minute // Support sessions should be very short-lived
	jobImpersonationDuration     = 2 * time.Hour    // Jobs get slightly longer but still limited
	adminImpersonationDuration   = 15 * time.Minute // Admin impersonation should be extremely short
	defaultImpersonationDuration = 15 * time.Minute // Conservative default for unknown types
)

// CreateImpersonationToken creates a JWT token for user impersonation
func (tm *TokenManager) CreateImpersonationToken(_ context.Context, opts CreateImpersonationTokenOptions) (string, error) {
	if opts.Duration == 0 {
		// Default duration based on impersonation type
		switch opts.Type {
		case "support":
			opts.Duration = supportImpersonationDuration
		case "job":
			opts.Duration = jobImpersonationDuration
		case "admin":
			opts.Duration = adminImpersonationDuration
		default:
			opts.Duration = defaultImpersonationDuration
		}
	}

	now := time.Now()
	sessionID := ulids.New().String()

	claims := &ImpersonationClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			IssuedAt:  jwt.NewNumericDate(now),
			ExpiresAt: jwt.NewNumericDate(now.Add(opts.Duration)),
			NotBefore: jwt.NewNumericDate(now),
			Issuer:    tm.conf.Issuer,
			Subject:   opts.TargetUserID,
			Audience:  jwt.ClaimStrings{tm.conf.Audience},
			ID:        sessionID,
		},
		UserID:            opts.TargetUserID,
		OrgID:             opts.OrganizationID,
		ImpersonatorID:    opts.ImpersonatorID,
		ImpersonatorEmail: opts.ImpersonatorEmail,
		Type:              opts.Type,
		Reason:            opts.Reason,
		SessionID:         sessionID,
		Scopes:            opts.Scopes,
		TargetUserEmail:   opts.TargetUserEmail,
		OriginalToken:     opts.OriginalToken,
	}

	token := jwt.NewWithClaims(signingMethod, claims)

	// Add key ID to header
	if tm.conf.KID != "" {
		token.Header["kid"] = tm.conf.KID
	}

	return tm.Sign(token)
}

// ValidateImpersonationToken validates and parses an impersonation token
func (tm *TokenManager) ValidateImpersonationToken(ctx context.Context, tokenString string) (*ImpersonationClaims, error) {
	var token *jwt.Token

	claims := &ImpersonationClaims{}

	// Parse with validation
	parser := jwt.NewParser(
		jwt.WithValidMethods([]string{signingMethod.Alg()}),
		jwt.WithAudience(tm.conf.Audience),
		jwt.WithIssuer(tm.conf.Issuer),
	)

	token, err := parser.ParseWithClaims(tokenString, claims, tm.keyFunc)
	if err != nil {
		return nil, err
	}

	if !token.Valid {
		return nil, ErrInvalidToken
	}

	// Check if the token has been blacklisted
	if tm.blacklist != nil && claims.SessionID != "" {
		revoked, err := tm.blacklist.IsRevoked(ctx, claims.SessionID)

		if revoked {
			log.Warn().Str("session_id", claims.SessionID).Msg("impersonation token is revoked")
			return nil, ErrTokenInvalid
		}
		// swallow this error intentionally, we don't want to block validation if blacklist check fails - auth should still succeed
		if err != nil {
			log.Warn().Msgf("failed to check blacklist for session %s: %v", claims.SessionID, err)
		}
	}

	// Additional validation specific to impersonation
	if claims.Type == "" {
		return nil, ErrMissingImpersonationType
	}

	if claims.ImpersonatorID == "" {
		return nil, ErrMissingImpersonatorID
	}

	if claims.UserID == "" {
		return nil, ErrMissingTargetUserID
	}

	return claims, nil
}

// RevokeImpersonationToken revokes an impersonation token by adding it to the blacklist
func (tm *TokenManager) RevokeImpersonationToken(ctx context.Context, sessionID string, ttl time.Duration) error {
	if tm.blacklist == nil {
		// No blacklist configured, tokens cannot be revoked
		return nil
	}

	return tm.blacklist.Revoke(ctx, sessionID, ttl)
}

// RevokeToken revokes a JWT token by its ID
func (tm *TokenManager) RevokeToken(ctx context.Context, tokenID string, ttl time.Duration) error {
	if tm.blacklist == nil {
		// No blacklist configured, tokens cannot be revoked
		return nil
	}

	return tm.blacklist.Revoke(ctx, tokenID, ttl)
}

// SuspendUser suspends all tokens for a user
func (tm *TokenManager) SuspendUser(ctx context.Context, userID string, ttl time.Duration) error {
	if tm.blacklist == nil {
		// No blacklist configured, users cannot be suspended
		return nil
	}

	return tm.blacklist.RevokeAllForUser(ctx, userID, ttl)
}

// GetBlacklist returns the configured blacklist (for internal use)
func (tm *TokenManager) GetBlacklist() TokenBlacklist {
	return tm.blacklist
}

// IsUserSuspended checks if a user is currently suspended
func (tm *TokenManager) IsUserSuspended(ctx context.Context, userID string) (bool, error) {
	if tm.blacklist == nil {
		return false, nil
	}

	return tm.blacklist.IsUserRevoked(ctx, userID)
}

// GetUserSuspensionStatus returns detailed suspension information
type SuspensionStatus struct {
	UserID    string
	Suspended bool
	// Future: could add SuspendedAt, ExpiresAt, Reason if we store metadata
}

// GetUserSuspensionStatus gets detailed suspension information for a user
func (tm *TokenManager) GetUserSuspensionStatus(ctx context.Context, userID string) (*SuspensionStatus, error) {
	suspended, err := tm.IsUserSuspended(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &SuspensionStatus{
		UserID:    userID,
		Suspended: suspended,
	}, nil
}

// IsTokenRevoked checks if a specific token (by JWT ID) has been revoked
func (tm *TokenManager) IsTokenRevoked(ctx context.Context, tokenID string) (bool, error) {
	if tm.blacklist == nil {
		return false, nil
	}

	return tm.blacklist.IsRevoked(ctx, tokenID)
}

// RevokeTokenWithTTL revokes a token with a specific TTL (alias for RevokeToken for clarity)
func (tm *TokenManager) RevokeTokenWithTTL(ctx context.Context, tokenID string, ttl time.Duration) error {
	return tm.RevokeToken(ctx, tokenID, ttl)
}

// SuspendUserWithDuration suspends a user for a specific duration (alias for SuspendUser for clarity)
func (tm *TokenManager) SuspendUserWithDuration(ctx context.Context, userID string, duration time.Duration) error {
	return tm.SuspendUser(ctx, userID, duration)
}

// CreateTokenPair returns signed access and refresh tokens for the specified claims in one step since usually you want both access and refresh tokens at the same time
func (tm *TokenManager) CreateTokenPair(claims *Claims) (accessToken, refreshToken string, err error) {
	var atk, rtk *jwt.Token

	if atk, err = tm.CreateAccessToken(claims); err != nil {
		return "", "", fmt.Errorf("could not create access token: %w", err)
	}

	if rtk, err = tm.CreateRefreshToken(atk); err != nil {
		return "", "", fmt.Errorf("could not create refresh token: %w", err)
	}

	if accessToken, err = tm.Sign(atk); err != nil {
		return "", "", fmt.Errorf("could not sign access token: %w", err)
	}

	if refreshToken, err = tm.Sign(rtk); err != nil {
		return "", "", fmt.Errorf("could not sign refresh token: %w", err)
	}

	return
}

// CreateToken from the claims payload without modifying the claims unless the claims
// are missing required fields that need to be updated
func (tm *TokenManager) CreateToken(claims *Claims) *jwt.Token {
	if len(claims.Audience) == 0 {
		claims.Audience = jwt.ClaimStrings{tm.audience}
	}

	if claims.Issuer == "" {
		claims.Issuer = tm.issuer
	}

	return jwt.NewWithClaims(signingMethod, claims)
}

// CreateAccessToken from the credential payload or from an previous token if the access token is being reauthorized from previous credentials or an already issued access token
func (tm *TokenManager) CreateAccessToken(claims *Claims) (_ *jwt.Token, err error) {
	// Create the claims for the access token, using access token defaults
	now := time.Now()
	sub := claims.Subject

	var kid ulid.ULID

	if kid, err = tm.genKeyID(); err != nil {
		return nil, err
	}

	issueTime := jwt.NewNumericDate(now)
	claims.RegisteredClaims = jwt.RegisteredClaims{
		ID:        strings.ToLower(kid.String()), // ID is randomly generated and shared between access and refresh
		Subject:   sub,
		Audience:  jwt.ClaimStrings{tm.audience},
		Issuer:    tm.issuer,
		IssuedAt:  issueTime,
		NotBefore: issueTime,
		ExpiresAt: jwt.NewNumericDate(now.Add(tm.conf.AccessDuration)),
	}

	return tm.CreateToken(claims), nil
}

// CreateRefreshToken from the Access token claims with predefined expiration
func (tm *TokenManager) CreateRefreshToken(accessToken *jwt.Token) (refreshToken *jwt.Token, err error) {
	accessClaims, ok := accessToken.Claims.(*Claims)
	if !ok {
		return nil, ErrFailedRetrieveClaimsFromToken
	}

	audience := accessClaims.Audience

	// Append the refresh token audience to the audience claims
	audience = append(audience, tm.RefreshAudience())

	// Create claims for the refresh token from the access token defaults
	claims := &Claims{
		RegisteredClaims: jwt.RegisteredClaims{
			ID:        accessClaims.ID, // ID is randomly generated and shared between access and refresh tokens
			Audience:  audience,
			Issuer:    accessClaims.Issuer,
			Subject:   accessClaims.Subject,
			IssuedAt:  accessClaims.IssuedAt,
			NotBefore: jwt.NewNumericDate(accessClaims.ExpiresAt.Add(tm.conf.RefreshOverlap)),
			ExpiresAt: jwt.NewNumericDate(accessClaims.IssuedAt.Add(tm.conf.RefreshDuration)),
		},
		OrgID: accessClaims.OrgID,
	}

	return tm.CreateToken(claims), nil
}

// Keys returns the JWKS with public keys for use externally
func (tm *TokenManager) Keys() (keys jwk.Set, err error) {
	keys = jwk.NewSet()
	for kid, pubkey := range tm.keys {
		var key jwk.Key

		if key, err = jwk.Import(pubkey); err != nil {
			return nil, err
		}

		if err = key.Set(jwk.KeyIDKey, kid); err != nil {
			return nil, err
		}

		if err = key.Set(jwk.KeyUsageKey, jwk.ForSignature); err != nil {
			return nil, err
		}

		// NOTE: the algorithm should match the signing method of this package
		if err = key.Set(jwk.AlgorithmKey, jwa.EdDSA().String()); err != nil {
			return nil, err
		}

		if err = keys.AddKey(key); err != nil {
			return nil, err
		}
	}

	return keys, nil
}

// RefreshAudience returns the refresh audience for the token manager; The refresh audience in plain-human-speak is the URL where the refresh token should be sent for validation (which is our api endpoint)
func (tm *TokenManager) RefreshAudience() string {
	if tm.refreshAudience == "" {
		if tm.conf.RefreshAudience != "" {
			tm.refreshAudience = tm.conf.RefreshAudience
		}

		if aud, err := url.Parse(tm.issuer); err == nil {
			tm.refreshAudience = aud.ResolveReference(&url.URL{Path: "/v1/refresh"}).String()
		} else {
			tm.refreshAudience = DefaultRefreshAudience
		}
	}

	return tm.refreshAudience
}

// Config returns the token manager config
func (tm *TokenManager) Config() Config {
	return tm.conf
}

// CurrentKey returns the ULID of the current key if it is ULID formatted; otherwise nilID is returned.
func (tm *TokenManager) CurrentKey() ulid.ULID {
	if id, err := ulid.Parse(tm.currentKeyID); err == nil {
		return id
	}

	return nilID
}

// CurrentKeyID returns the identifier of the current signing key.
func (tm *TokenManager) CurrentKeyID() string {
	return tm.currentKeyID
}

// AddSigningKey registers a new signing key identified by the supplied ULID.
// NOTE: Breaking change in EdDSA migration â€“ callers must now supply a crypto.Signer (ed25519)
// and handle a potential error response.
func (tm *TokenManager) AddSigningKey(keyID ulid.ULID, key crypto.Signer) error {
	return tm.AddSigningKeyWithID(keyID.String(), key)
}

// AddSigningKeyWithID registers a new signing key with an arbitrary string identifier.
func (tm *TokenManager) AddSigningKeyWithID(kid string, key crypto.Signer) error {
	if kid == "" {
		return ErrEmptySigningKeyID
	}

	return tm.addSigningKeyWithID(kid, key)
}

func (tm *TokenManager) addSigningKeyWithID(kid string, signer crypto.Signer) error {
	publicKey, ok := signer.Public().(ed25519.PublicKey)
	if !ok || len(publicKey) != ed25519.PublicKeySize {
		return ErrInvalidSigningKey
	}

	tm.keys[kid] = publicKey
	tm.signingKeys[kid] = signer

	if tm.currentKey == nil {
		tm.currentKey = signer
		tm.currentKeyID = kid
		tm.conf.KID = kid

		return nil
	}

	newULID, newErr := ulid.Parse(kid)
	newIsULID := newErr == nil
	currentULID, currentErr := ulid.Parse(tm.currentKeyID)
	currentIsULID := currentErr == nil

	switch {
	case newIsULID && !currentIsULID:
		tm.currentKey = signer
		tm.currentKeyID = kid
		tm.conf.KID = kid
	case newIsULID && currentIsULID && newULID.Time() > currentULID.Time():
		tm.currentKey = signer
		tm.currentKeyID = kid
		tm.conf.KID = kid
	}

	return nil
}

func (tm *TokenManager) selectInitialKey(loaded []loadedKey, desired string) {
	if desired != "" {
		if signer, ok := tm.signingKeys[desired]; ok {
			tm.currentKeyID = desired
			tm.currentKey = signer

			return
		}
	}

	var chosen string

	var chosenULID ulid.ULID

	var hasULID bool

	for _, info := range loaded {
		if info.hasULID {
			if !hasULID || info.ulid.Time() > chosenULID.Time() {
				chosen = info.kid
				chosenULID = info.ulid
				hasULID = true
			}
		}
	}

	if !hasULID && len(loaded) > 0 {
		chosen = loaded[len(loaded)-1].kid
	}

	if chosen != "" {
		tm.currentKeyID = chosen
		tm.currentKey = tm.signingKeys[chosen]
		tm.conf.KID = chosen
	}
}

// UseSigningKey sets the current signing key to the key specified by keyID.
// It returns ErrUnknownSigningKey if the key has not been registered.
func (tm *TokenManager) UseSigningKey(keyID ulid.ULID) error {
	return tm.UseSigningKeyID(keyID.String())
}

// UseSigningKeyID sets the current signing key to the key specified by kid.
// It returns ErrUnknownSigningKey if the key has not been registered.
func (tm *TokenManager) UseSigningKeyID(kid string) error {
	key, ok := tm.signingKeys[kid]
	if !ok {
		return ErrUnknownSigningKey
	}

	tm.currentKey = key
	tm.currentKeyID = kid
	tm.conf.KID = kid

	return nil
}

// RemoveSigningKey deletes the signing key identified by keyID. If the removed
// key is the currently active signing key the newest remaining key will become
// active. Removing a key ensures any tokens referencing it can no longer be
// validated.
func (tm *TokenManager) RemoveSigningKey(keyID ulid.ULID) {
	tm.RemoveSigningKeyByID(keyID.String())
}

// RemoveSigningKeyByID deletes the signing key identified by kid.
func (tm *TokenManager) RemoveSigningKeyByID(kid string) {
	delete(tm.keys, kid)
	delete(tm.signingKeys, kid)

	if len(tm.signingKeys) == 0 {
		tm.currentKey = nil
		tm.currentKeyID = ""
		tm.conf.KID = ""

		return
	}

	if tm.currentKeyID == kid {
		remaining := make([]loadedKey, 0, len(tm.signingKeys))

		keyIDs := make([]string, 0, len(tm.signingKeys))
		for id := range tm.signingKeys {
			keyIDs = append(keyIDs, id)
		}

		sort.Strings(keyIDs)

		for _, id := range keyIDs {
			info := loadedKey{kid: id}
			if parsed, err := ulid.Parse(id); err == nil {
				info.ulid = parsed
				info.hasULID = true
			}

			remaining = append(remaining, info)
		}

		tm.currentKey = nil
		tm.currentKeyID = ""
		tm.selectInitialKey(remaining, tm.conf.KID)

		if tm.currentKey != nil {
			tm.conf.KID = tm.currentKeyID
		}
	}
}


// keyFunc selects the Ed25519 public key from the list of tokenmanager internal keys based on the kid in the token header - if the kid does not exist an error is returned the token is not validated
func (tm *TokenManager) keyFunc(token *jwt.Token) (key interface{}, err error) {
	// Per JWT security notice: do not forget to validate alg is expected, else haxorz!~
	if token.Method.Alg() != signingMethod.Alg() {
		return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"]) //nolint:err113
	}

	// Fetch that kid
	kid, ok := token.Header["kid"]
	if !ok {
		return nil, ErrTokenMissingKid
	}

	// Fetch the key from the list of managed keys
	kidStr, ok := kid.(string)
	if !ok {
		return nil, ErrFailedParsingKid
	}

	if key, ok = tm.keys[kidStr]; !ok {
		return nil, ErrUnknownSigningKey
	}

	return key, nil
}

// genKeyID generates a ulid for a key (the identifier of the key)
func (tm *TokenManager) genKeyID() (uid ulid.ULID, err error) {
	ms := ulid.Timestamp(time.Now())
	if uid, err = ulid.New(ms, tm.kidEntropy); err != nil {
		return uid, fmt.Errorf("could not generate key id: %w", err)
	}

	return uid, nil
}

// ParseUnverified parses a string of tokens and returns the claims and any error encountered
func ParseUnverified(tks string) (claims *jwt.RegisteredClaims, err error) {
	claims = &jwt.RegisteredClaims{}
	parser := jwt.NewParser(jwt.WithoutClaimsValidation())

	if _, _, err = parser.ParseUnverified(tks, claims); err != nil {
		return nil, err
	}

	return claims, nil
}

// ParseUnverifiedTokenClaims parses token claims from an access token
func ParseUnverifiedTokenClaims(tks string) (claims *Claims, err error) {
	claims = &Claims{}
	parser := jwt.NewParser(jwt.WithoutClaimsValidation())

	if _, _, err = parser.ParseUnverified(tks, claims); err != nil {
		return nil, err
	}

	return claims, nil
}

// ExpiresAt parses a JWT token and returns the expiration time if it exists
func ExpiresAt(tks string) (_ time.Time, err error) {
	var claims *jwt.RegisteredClaims

	if claims, err = ParseUnverified(tks); err != nil {
		return time.Time{}, err
	}

	return claims.ExpiresAt.Time, nil
}

// NotBefore parses a JWT token and returns the "NotBefore" time claim if it exists
func NotBefore(tks string) (_ time.Time, err error) {
	var claims *jwt.RegisteredClaims

	if claims, err = ParseUnverified(tks); err != nil {
		return time.Time{}, err
	}

	return claims.NotBefore.Time, nil
}

// IsExpired attempts to check if the provided token is expired
func IsExpired(tks string) (bool, error) {
	expiration, err := ExpiresAt(tks)
	if err != nil {
		return true, err
	}

	// check if token is expired
	if expiration.Before(time.Now()) {
		return true, nil
	}

	return false, nil
}

// ImpersonationClaims extends the standard JWT claims with impersonation-specific information
type ImpersonationClaims struct {
	jwt.RegisteredClaims
	// UserID is the user being impersonated
	UserID string `json:"user_id,omitempty"`
	// OrgID is the organization context
	OrgID string `json:"org,omitempty"`
	// ImpersonatorID is the user doing the impersonation
	ImpersonatorID string `json:"impersonator_id"`
	// ImpersonatorEmail is the email of the impersonator
	ImpersonatorEmail string `json:"impersonator_email"`
	// Type indicates the type of impersonation (support, job, admin)
	Type string `json:"type"`
	// Reason for the impersonation
	Reason string `json:"reason"`
	// SessionID uniquely identifies this impersonation session
	SessionID string `json:"session_id"`
	// Scopes defines what actions are allowed
	Scopes []string `json:"scopes"`
	// TargetUserEmail is the email of the user being impersonated
	TargetUserEmail string `json:"target_user_email"`
	// OriginalToken stores the original user's token for reference
	OriginalToken string `json:"original_token,omitempty"`
}

// CreateImpersonationTokenOptions contains options for creating impersonation tokens
type CreateImpersonationTokenOptions struct {
	ImpersonatorID    string
	ImpersonatorEmail string
	TargetUserID      string
	TargetUserEmail   string
	OrganizationID    string
	Type              string
	Reason            string
	Duration          time.Duration
	Scopes            []string
	OriginalToken     string
}

// ParseUserID returns the target user ID from impersonation claims
func (c ImpersonationClaims) ParseUserID() ulid.ULID {
	userID, err := ulid.Parse(c.UserID)
	if err != nil {
		return ulids.Null
	}

	return userID
}

// ParseOrgID returns the organization ID from impersonation claims
func (c ImpersonationClaims) ParseOrgID() ulid.ULID {
	orgID, err := ulid.Parse(c.OrgID)
	if err != nil {
		return ulids.Null
	}

	return orgID
}

// ParseImpersonatorID returns the impersonator user ID from claims
func (c ImpersonationClaims) ParseImpersonatorID() ulid.ULID {
	impersonatorID, err := ulid.Parse(c.ImpersonatorID)
	if err != nil {
		return ulids.Null
	}

	return impersonatorID
}

// HasScope checks if the impersonation token has a specific scope
func (c ImpersonationClaims) HasScope(scope string) bool {
	for _, s := range c.Scopes {
		if s == scope || s == "*" {
			return true
		}
	}

	return false
}

// GetSessionID returns the session ID for this impersonation
func (c ImpersonationClaims) GetSessionID() string {
	return c.SessionID
}

// IsJobImpersonation returns true if this is a job impersonation token
func (c ImpersonationClaims) IsJobImpersonation() bool {
	return c.Type == "job"
}

// IsSupportImpersonation returns true if this is a support impersonation token
func (c ImpersonationClaims) IsSupportImpersonation() bool {
	return c.Type == "support"
}

// IsAdminImpersonation returns true if this is an admin impersonation token
func (c ImpersonationClaims) IsAdminImpersonation() bool {
	return c.Type == "admin"
}
