{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "authFromMutation" }}
// Code generated by entfga, DO NOT EDIT.

    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    {{/* Add imports so the correct packages are imported */}}
    import (
        "github.com/theopenlane/iam/fgax"
        "github.com/theopenlane/iam/entfga"
        "github.com/theopenlane/entx"
    )

    {{/* Add Check for Soft Delete See: AuthzConfig.SoftDeletes */}}
    {{ $softDeletes := $.Annotations.AuthzConfig.SoftDeletes }}

    {{ range $n := $.Nodes }}
    {{ $name := $n.Name }}
        {{ $mutator := $n.MutationName }}
        {{/* Only include nodes with the Authz annotation with hooks. See: Annotation.Name */}}
        {{ if and ($n.Annotations.Authz) ($n.Annotations.Authz.IncludeHooks) }}

            {{- $objectType := extractObjectType $n.Annotations.Authz.ObjectType }}
            func (m *{{ $mutator }}) CreateTuplesFromCreate(ctx context.Context) error {
                {{- $includeHooks := extractIncludeHooks $n.Annotations.Authz.IncludeHooks }}
                // Get fields for tuple creation
                userID, _ := m.UserID()
                objectID, _ := m.{{ $objectType | ToUpperCamel }}ID()
                role, _ := m.Role()

                // get tuple key
                req := fgax.TupleRequest{
                    SubjectID:   userID,
                    SubjectType: "user",
                    ObjectID: objectID,
                    ObjectType: "{{ $objectType | ToLower }}",
                    Relation: role.String(),
                }

                tuple := fgax.GetTupleKey(req)

                if _, err := m.Authz.WriteTupleKeys(ctx, []fgax.TupleKey{tuple}, nil); err != nil {
                    log.Error().Err(err).Interface("writes", tuple).Msg("failed to create relationship tuple")

                    return err
                }

                log.Debug().Interface("tuple_request", tuple).Msg("created relationship tuple")

                return nil
            }

            func (m *{{ $mutator }}) CreateTuplesFromUpdate(ctx context.Context) error {
                {{- $includeHooks := extractIncludeHooks $n.Annotations.Authz.IncludeHooks }}

                // get ids that will be updated
                ids, err := m.IDs(ctx)
                if err != nil {
                    log.Error().Err(err).Msg("failed to get ids for update")

                    return err
                }

                // check for the single update case
                if len(ids) == 0 {
                    id, exists := m.ID()
                    if exists {
                        // singular delete
                        ids = append(ids, id)
                    }
                }

                var (
                    writes  []fgax.TupleKey
                    deletes []fgax.TupleKey
                )

                oldRole, err := m.OldRole(ctx)
                if err != nil {
                    return err
                }

                newRole, exists := m.Role()
                if !exists {
                    return entfga.ErrMissingRole
                }

                if oldRole == newRole {
                    log.Debug().
                        Str("old_role", oldRole.String()).
                        Str("new_role", newRole.String()).
                        Msg("nothing to update, roles are the same")

                    return nil
                }

                members := []*{{ $name }}{}

                // use the predicates from the original request to get the members if we don't have ids
                if len(ids) == 0 {
                    members, err = m.Client().{{ $name }}.Query().Where(m.predicates...).All(ctx)
                } else {
                    members, err = m.Client().{{ $name }}.Query().Where({{ $name | ToLower }}.IDIn(ids...)).All(ctx)
                }

                if err != nil || len(members) == 0 {
                    log.Error().Err(err).Msg("failed to get members for update")

                    return err
                }

                // Delete all related tuples
                for _, member := range members {
                    req := fgax.TupleRequest{
                        SubjectID:   member.UserID,
                        SubjectType: "user",
                        ObjectID:  member.{{ $objectType | ToUpperCamel }}ID,
                        ObjectType: "{{ $objectType | ToLower }}",
                        Relation: oldRole.String(),
                    }

                    d := fgax.GetTupleKey(req)
                    deletes = append(deletes, d)

                    req.Relation = newRole.String()

                    w := fgax.GetTupleKey(req)
                    writes = append(writes, w)

                    if len(writes) == 0 && len(deletes) == 0 {
                        log.Debug().Msg("no relationships to create or delete")

                        return nil
                    }

                    if _, err := m.Authz.WriteTupleKeys(ctx, writes, deletes); err != nil {
                        log.Error().Err(err).Interface("writes", writes).Interface("deletes", deletes).Msg("failed to update relationship tuple")

                        return err
                    }
                }

                return nil
            }

            func (m *{{ $mutator }}) CreateTuplesFromDelete(ctx context.Context) error {
                {{- $includeHooks := extractIncludeHooks $n.Annotations.Authz.IncludeHooks }}
                // get ids that will be deleted
                ids, err := m.IDs(ctx)
                if err != nil {
                    return err
                }

                // check for the single delete case
                if len(ids) == 0 {
                    id, exists := m.ID()
                    if exists {
                        // singular delete
                        ids = append(ids, id)
                    }
                }

                tuples := []fgax.TupleKey{}

                members := []*{{ $name }}{}

                // use the predicates from the original request to get the members if we don't have ids
                {{- if $softDeletes }}
                ctx = entx.SkipSoftDelete(ctx)
                {{- end }}
                if len(ids) == 0 {
                    // this will not work for the soft delete case because the predicates will include deleted_at = nil
                    // and this hook is setup to run after the delete happens
                    members, err = m.Client().{{ $name }}.Query().Where(m.predicates...).All(ctx)
                } else {
                    members, err = m.Client().{{ $name }}.Query().Where({{ $name | ToLower }}.IDIn(ids...)).All(ctx)
                }

                if err != nil || len(members) == 0 {
                    log.Error().Err(err).Msg("failed to get members for delete")

                    return err
                }

                // Delete all related tuples
                for _, member := range members {
                    req := fgax.TupleRequest{
                        SubjectID:   member.UserID,
                        SubjectType: "user",
                        ObjectID:  member.{{ $objectType | ToUpperCamel }}ID,
                        ObjectType: "{{ $objectType | ToLower }}",
                        Relation: member.Role.String(),
                    }

                    t := fgax.GetTupleKey(req)
                    tuples = append(tuples, t)
                }

                if len(tuples) > 0 {
                    if _, err := m.Authz.WriteTupleKeys(ctx, nil, tuples); err != nil {
                        log.Error().Err(err).Interface("deletes", tuples).Msg("failed to delete relationship tuple")

                        return err
                    }

                    log.Debug().Msg("deleted relationship tuples")
                }

                return nil
            }
    {{ end }}
    {{ end }}
{{ end }}