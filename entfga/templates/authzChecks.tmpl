// Code generated by entfga, DO NOT EDIT.
package {{ .GeneratedPkg }}

{{/* Add imports so the correct privacy package is imported */}}
import (
    "github.com/99designs/gqlgen/graphql"
    "entgo.io/ent/privacy"
    "github.com/rs/zerolog/log"

    "github.com/theopenlane/iam/fgax"
    "github.com/theopenlane/iam/auth"
)

var (
    ErrPermissionDenied = errors.New("you are not authorized to perform this action")
)

// newOrganizationContextKey creates a new context key for organization checks
// if the full email is provided it will take the domain after the `@` symbol
func newOrganizationContextKey(e string) *map[string]any {
    domain := e
    if strings.Contains(e, "@") {
        domain = strings.Split(e, "@")[1]
    }

    return &map[string]any{
        emailDomainContextKey: domain,
    }
}

{{- $nodes := .Graph.Nodes }}

{{- range $n := $nodes }}
    {{- $name := $n.Name }}
    {{- $defaultObjectType := extractDefaultObjectType $n.Name }}
    {{- $mutator := $n.MutationName }}
    {{- $querier := $n.QueryName }}
    {{- $isHistory := isHistorySchema $querier }}

    {{/* Only include nodes with the Authz check annotation. See: Annotations.Name */}}
    {{- if $n.Annotations.Authz }}

    {{- $objectType := or (extractObjectType $n.Annotations.Authz.ObjectType) $defaultObjectType }}
    {{- $idField := extractIDField $n.Annotations.Authz.IDField }}
    {{- $nillable := extractNillableIDField $n.Annotations.Authz.NillableIDField  }}
    {{- $orgOwned := extractOrgOwnedField $n.Annotations.Authz.OrgOwnedField  }}

    func (q *{{ $querier }}) CheckAccess(ctx context.Context) error {
        gCtx := graphql.GetFieldContext(ctx)

        if gCtx == nil {
            // Skip to the next privacy rule (equivalent to return nil)
            // if this is not a graphql request
            return privacy.Skipf("not a graphql request, no context to check")
        }

        au, err := auth.GetAuthenticatedUserFromContext(ctx)
        if err != nil {
            log.Error().Err(err).Msg("unable to get authenticated user from context")
            return privacy.Skipf("unable to get authenticated user from context")
        }

        var objectID string

        // check id from graphql arg context
        // when all objects are requested, the interceptor will check object access
        // check the where input first
        whereArg := gCtx.Args["where"]
        if whereArg != nil {
            where, ok := whereArg.(*{{ $name }}WhereInput)
            if ok && where != nil && where.{{ $idField }} != nil {
                objectID = *where.{{ $idField }}
            }
        }

        // if that doesn't work, check for the id in the request args
        if objectID == "" {
            objectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
        }

        {{ if ne $idField "ID" }}
        // if we still don't have an object id, run the query and grab the object ID
        // from the result
        // this happens on join tables where we have the join ID (for updates and deletes)
        // and not the actual object id
        if objectID == "" {
            // allow this query to run
            reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

            ob, err := q.Clone().Only(reqCtx)
            if err != nil {
                return privacy.Allowf("nil request, bypassing auth check")
            }

            objectID = ob.{{ $idField }}
        }
        {{- end }}

        // request is for a list objects, will get filtered in interceptors
        if objectID == ""  {
            return privacy.Allowf("nil request, bypassing auth check")
        }

        // check if the user has access to the object requested
        ac := fgax.AccessCheck{
            {{- if $isHistory }}
            Relation: fgax.CanViewAuditLog,
            {{- else }}
            Relation: fgax.CanView,
            {{- end }}
            ObjectType:  "{{ $objectType | ToLower }}",
            SubjectType: auth.GetAuthzSubjectType(ctx),
            SubjectID: au.SubjectID,
            ObjectID: objectID,
            Context: newOrganizationContextKey(au.SubjectEmail),
        }

        access, err := q.Authz.CheckAccess(ctx, ac)
        if err == nil && access {
            return privacy.Allow
        }

        // Skip to the next privacy rule (equivalent to return nil)
        return privacy.Skip
    }

    {{ if $n.Annotations.EntGQL | hasMutationInputSet }}
    func (m *{{ $mutator }}) CheckAccessForEdit(ctx context.Context) error {
        var objectID string

        {{ if $orgOwned }}
        orgID, err := auth.GetOrganizationIDFromContext(ctx)
        if orgID == ""  || err != nil {
            // if we still don't have an object id, run the query and grab the object ID
            // from the result
            // this happens when using a personal access token since it is authorized for multiple orgs
            id, _ := m.ID()

            if id != "" {
                // allow this query to run
                reqCtx := privacy.DecisionContext(ctx, privacy.Allow)

                ob, err := m.Client().{{ $name }}.Get(reqCtx, id)
                if err != nil {
                    log.Debug().Err(err).Msg("error getting object")

                    return err
                }

                orgID = ob.{{ $idField }}
            }
        }

        objectID = orgID
        {{ else }}

        gCtx := graphql.GetFieldContext(ctx)
        if gCtx == nil {
            // Skip to the next privacy rule (equivalent to return nil)
            // if this is not a graphql request
            return privacy.Skipf("not a graphql request, no context to check")
        }

        {{ if hasCreateID $n.Annotations.Authz.IDField }}
        // get the input from the context
        gInput := gCtx.Args["input"]

        // check if the input is a Create{{ $name }}Input
        input, ok := gInput.(Create{{ $name }}Input)
        if ok {
            {{- if $nillable }}
            objectID = *input.{{ $idField }}
            {{ else }}
            objectID = input.{{ $idField }}
            {{ end }}
        }
        {{- end }}

        // check the id from the args
        if objectID == "" {
            objectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
        }

        {{- if ne $idField "ID" }}
        // if this is still empty, we need to query the object to get the object id
        // this happens on join tables where we have the join ID (for updates and deletes)
        if objectID == "" {
            id, ok := gCtx.Args["id"].(string)
            if ok {
                // allow this query to run
                reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                ob, err := m.Client().{{ $name }}.Query().Where({{ $name | ToLower }}.ID(id)).Only(reqCtx)
                if err != nil {
                    return privacy.Skipf("nil request, skipping auth check")
                }
                objectID = ob.{{ $idField }}
            }
        }
        {{- end }}
        {{- end }}

        // request is for a list objects, will get filtered in interceptors
        if objectID == ""  {
            return privacy.Allowf("nil request, bypassing auth check")
        }

        au, err := auth.GetAuthenticatedUserFromContext(ctx)
        if err != nil {
            log.Error().Err(err).Msg("unable to get authenticated user from context")
            return privacy.Skipf("unable to get authenticated user from context")
        }

        ac := fgax.AccessCheck{
            Relation: fgax.CanEdit,
            ObjectType:  "{{ $objectType | ToLower }}",
            ObjectID: objectID,
            SubjectType: auth.GetAuthzSubjectType(ctx),
            SubjectID: au.SubjectID,
            Context: newOrganizationContextKey(au.SubjectEmail),
        }

        log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

        access, err := m.Authz.CheckAccess(ctx, ac)
        if err == nil && access {
            return privacy.Allow
        }

        log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

        // return error if the action is not allowed
        return ErrPermissionDenied
    }

    func (m *{{ $mutator }}) CheckAccessForDelete(ctx context.Context) error {
        gCtx := graphql.GetFieldContext(ctx)
        if gCtx == nil {
            // Skip to the next privacy rule (equivalent to return nil)
            // if this is not a graphql request
            return privacy.Skipf("not a graphql request, no context to check")
        }

        objectID, ok := gCtx.Args["id"].(string)
        if !ok {
            log.Info().Msg("no id found in args, skipping auth check, will be filtered in hooks")

            return privacy.Allowf("nil request, bypassing auth check")
        }

        au, err := auth.GetAuthenticatedUserFromContext(ctx)
        if err != nil {
            log.Error().Err(err).Msg("unable to get authenticated user from context")
            return privacy.Skipf("unable to get authenticated user from context")
        }

        ac := fgax.AccessCheck{
            Relation: fgax.CanDelete,
            ObjectType:  "{{ $objectType | ToLower }}",
            ObjectID: objectID,
            SubjectType: auth.GetAuthzSubjectType(ctx),
            SubjectID: au.SubjectID,
            Context: newOrganizationContextKey(au.SubjectEmail),
        }

        log.Debug().Interface("access_check", ac).Msg("checking relationship tuples")

        access, err := m.Authz.CheckAccess(ctx, ac)
        if err == nil && access {
            return privacy.Allow
        }

        log.Error().Interface("access_check", ac).Bool("access_result", access).Msg("access denied")

        // return error if the action is not allowed
        return ErrPermissionDenied
    }
    {{- end }}
    {{- end }}
{{- end }}