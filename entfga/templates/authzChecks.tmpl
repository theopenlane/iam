// Code generated by entfga, DO NOT EDIT.
package {{ .GeneratedPkg }}

{{/* Add imports so the correct privacy package is imported */}}
import (
    "github.com/99designs/gqlgen/graphql"
    "entgo.io/ent/privacy"

    "github.com/theopenlane/iam/fgax"
    "github.com/theopenlane/iam/auth"
)

{{- $nodes := .Graph.Nodes }}

{{- range $n := $nodes }}
    {{- $name := $n.Name }}
    {{- $mutator := $n.MutationName }}
    {{- $querier := $n.QueryName }}

    {{/* Only include nodes with the Authz check anntoation. See: Annotations.Name */}}
    {{- if $n.Annotations.Authz }}

    {{- $objectType := extractObjectType $n.Annotations.Authz.ObjectType }}
    {{- $idField := extractIDField $n.Annotations.Authz.IDField  }}
    {{- $nillable := extractNillableIDField $n.Annotations.Authz.NillableIDField  }}
    {{- $orgOwned := extractOrgOwnedField $n.Annotations.Authz.OrgOwnedField  }}

    func (q *{{ $querier }}) CheckAccess(ctx context.Context) error {
        gCtx := graphql.GetFieldContext(ctx)

        if gCtx != nil {
            ac := fgax.AccessCheck{
                Relation: fgax.CanView,
                ObjectType:  "{{ $objectType | ToLower }}",
                SubjectType: auth.GetAuthzSubjectType(ctx),
            }

            // check id from graphql arg context
            // when all objects are requested, the interceptor will check object access
            // check the where input first
            whereArg := gCtx.Args["where"]
            if whereArg != nil {
                where, ok := whereArg.(*{{ $name }}WhereInput)
                if ok && where != nil && where.{{ $idField }} != nil {
                    ac.ObjectID = *where.{{ $idField }}
                }
            }

            // if that doesn't work, check for the id in the args
            if ac.ObjectID == "" {
                ac.ObjectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
            }

            // if we still don't have an object id, run the query and grab the object ID
            // from the result
            // this happens on join tables where we have the join ID (for updates and deletes)
            // and not the actual object id
            if ac.ObjectID == "" && "id" !=  "{{ $idField | ToLower }}" {
                // allow this query to run
                reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                ob, err := q.Clone().Only(reqCtx)
                if err != nil {
                    return privacy.Allowf("nil request, bypassing auth check")
                }
                ac.ObjectID = ob.{{ $idField }}
            }

            // request is for a list objects, will get filtered in interceptors
            if ac.ObjectID == ""  {
                return privacy.Allowf("nil request, bypassing auth check")
            }

            var err error
            ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
            if err != nil {
                return err
            }


            access, err := q.Authz.CheckAccess(ctx, ac)
            if err != nil {
                return privacy.Skipf("unable to check access, %s", err.Error())
            }

            if access {
                return privacy.Allow
            }
        }

        // Skip to the next privacy rule (equivalent to return nil)
        return privacy.Skip
    }

    {{- if $n.Annotations.EntGQL | hasMutationInputSet }}
    func (m *{{ $mutator }}) CheckAccessForEdit(ctx context.Context) error {
        ac := fgax.AccessCheck{
            Relation: fgax.CanEdit,
            ObjectType:  "{{ $objectType | ToLower }}",
            SubjectType: auth.GetAuthzSubjectType(ctx),
        }

        {{- if $orgOwned }}
        orgID, oErr := auth.GetOrganizationIDFromContext(ctx)

        // if we still don't have an object id, run the query and grab the object ID
        // from the result
        // this happens when using a personal access token since it is authorized for multiple orgs
        if orgID == ""  || oErr != nil {
            id, _ := m.ID()

            if id != "" {
                // allow this query to run
                reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                ob, err := m.Client().{{ $name }}.Get(reqCtx, id)
                if err != nil {
                    m.Logger.Debug().Err(err).Msg("error getting object")

                    return err
                }

                orgID = ob.{{ $idField }}
            }
        }

        ac.ObjectID = orgID
        {{ else }}

        gCtx := graphql.GetFieldContext(ctx)

        {{ if hasCreateID $n.Annotations.Authz.IDField }}
        // get the input from the context
        gInput := gCtx.Args["input"]

        // check if the input is a Create{{ $name }}Input
        input, ok := gInput.(Create{{ $name }}Input)
        if ok {
            {{- if $nillable }}
            ac.ObjectID = *input.{{ $idField }}
            {{ else }}
            ac.ObjectID = input.{{ $idField }}
            {{ end }}
        }
        {{- end }}

        // check the id from the args
        if ac.ObjectID == "" {
            ac.ObjectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
        }

        // if this is still empty, we need to query the object to get the object id
        // this happens on join tables where we have the join ID (for updates and deletes)
        if ac.ObjectID == "" && "id" !=  "{{ $idField | ToLower }}" {
            id, ok := gCtx.Args["id"].(string)
            if ok {
                // allow this query to run
                reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                ob, err := m.Client().{{ $name }}.Query().Where({{ $name | ToLower }}.ID(id)).Only(reqCtx)
                if err != nil {
                    return privacy.Skipf("nil request, skipping auth check")
                }
                ac.ObjectID = ob.{{ $idField }}
            }
        }
        {{- end }}

        // request is for a list objects, will get filtered in interceptors
        if ac.ObjectID == ""  {
            return privacy.Allowf("nil request, bypassing auth check")
        }

        m.Logger.Debug().Msg("checking mutation access")

        var err error
        ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
        if err != nil {
            return err
        }

        m.Logger.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

        access, err := m.Authz.CheckAccess(ctx, ac)
        if err != nil {
            return privacy.Skipf("unable to check access, %s", err.Error())
        }

        if access {
            m.Logger.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

            return privacy.Allow
        }

        // deny if it was a mutation is not allowed
        return privacy.Deny
    }

    func (m *{{ $mutator }}) CheckAccessForDelete(ctx context.Context) error {
        ac := fgax.AccessCheck{
            Relation: fgax.CanDelete,
            ObjectType:  "{{ $objectType | ToLower }}",
            SubjectType: auth.GetAuthzSubjectType(ctx),
        }

        gCtx := graphql.GetFieldContext(ctx)

        var ok bool
        ac.ObjectID, ok = gCtx.Args["id"].(string)
        if !ok {
            return privacy.Allowf("nil request, bypassing auth check")
        }

        m.Logger.Debug().Msg("checking mutation access")

        var err error
        ac.SubjectID, err = auth.GetUserIDFromContext(ctx)
        if err != nil {
            return err
        }

        m.Logger.Info().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("checking relationship tuples")

        access, err := m.Authz.CheckAccess(ctx, ac)
        if err != nil {
            return privacy.Skipf("unable to check access, %s", err.Error())
        }

        if access {
            m.Logger.Debug().Str("relation", ac.Relation).Str("object_id", ac.ObjectID).Msg("access allowed")

            return privacy.Allow
        }

        // deny if it was a mutation is not allowed
        return privacy.Deny
    }
    {{- end }}
    {{- end }}
{{- end }}